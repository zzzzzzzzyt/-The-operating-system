# 计算机网络查漏补缺



# 基础篇

## 2.1 TCP/IP 网络模型有哪几层？

综上所述，TCP/IP 网络通常是由上到下分成 4 层，分别是**应用层，传输层，网络层和网络接口层**。

![Snipaste_2022-05-12_08-50-52.png](https://s2.loli.net/2022/05/12/yImHaC8PqThAZJz.png)

再给大家贴一下每一层的封装格式：

![Snipaste_2022-05-12_08-51-02.png](https://s2.loli.net/2022/05/12/3CeGZv8xRBzbUj4.png)

网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。



## 2.2 键入网址到网页显示，期间发生了什么？





## 2.3 Linux 系统是如何收发网络包的？

电脑与电脑之间通常都是通话网卡、交换机、路由器等网络设备连接到一起，那由于网络设备的异构性，国际标准化组织定义了一个七层的 OSI 网络模型，但是这个模型由于比较复杂，实际应用中并没有采用，而是采用了更为简化的 TCP/IP 模型，Linux 网络协议栈就是按照了该模型来实现的。

TCP/IP 模型主要分为应用层、传输层、网络层、网络接口层四层，每一层负责的职责都不同，这也是 Linux 网络协议栈主要构成部分。

当应用程序通过 Socket 接口发送数据包，数据包会被网络协议栈从上到下进行逐层处理后，才会被送到网卡队列中，随后由网卡将网络包发送出去。

而在接收网络包时，同样也要先经过网络协议栈从下到上的逐层处理，最后才会被送到应用程序。







# HTTP篇

## 3.1 HTTP 常见面试题



## 3.2 HTTP/1.1如何优化？

这次主要从 3 个方面介绍了优化 HTTP/1.1 协议的思路。

第一个思路是，通过缓存技术来避免发送 HTTP 请求。客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。

第二个思路是，减少 HTTP 请求的次数，有以下的方法：

1. 将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数；
2. 将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗；
3. 按需访问资源，只访问当前用户看得到/用得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同一时间的 HTTP 请求次数。

第三思路是，通过压缩响应资源，降低传输资源的大小，从而提高传输效率，所以应当选择更优秀的压缩算法。

不管怎么优化 HTTP/1.1 协议都是有限的，不然也不会出现 HTTP/2 和 HTTP/3 协议，后续我们再来介绍 HTTP/2 和 HTTP/3 协议



# TCP篇







# IP篇

































# 自己记录的问题

- TCP/IP网络模型属于网络通信的一套通用的网络协议

- 应用层是工作在操作系统的用户态，传输层及以下则工作在内核态

- MSS（TCP最大报文段长度）

- 传输层的报文会携带端口号的，因此接收方可以识别出该报文是发送给哪个应用

- 网络层最常使用的是 IP 协议（*Internet Protocol*），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会**再次进行分片**，得到一个即将发送到网络的 IP 报文。

- IP地址主要分成两种意义，一个是网络号，一个是主机号，根据掩码可以获取两者

- **IP 协议的寻址作用是告诉我们去往下一个目的地==该朝哪个方向走==，路由则是==根据「下一个目的地」选择路径==。寻址更像在导航，路由更像在操作方向盘**。`自己用通俗的话讲一遍就是这个ip告诉我们最终要去哪个网络的哪台主机，路由的话就是咋去，遇到个路由器给他看，他帮你分配`

- 网络接口层会将网络层的数据封装成帧，根据mac头部进行转发

- ⭐其实我们访问对应的网址后面一系列的东西，其实最后都是请求他实际的域名的 比如`https://www.baidu.com/s?wd=杭州电子科技大学&rsv_spt=1&rsv_iqid=0xc992c3e7004b9c01&issp=1&f=8&rsv_bp=1&rsv_idx=2&ie=utf-8` 类似于这一段其实就是请求百度，后面是数据源的数据名，用来生成相应的请求报文发送给服务器域名进行请求

- 必须用到DNS因为委托操作系统发送消息的时候，必须提供通信对象的IP地址（浏览器中会有域名的缓存，每次都会先看是否有缓存，再去请求DNS）

- `MTU`：一个网络包的最大长度，以太网中一般为 `1500` 字节。
  `MSS`：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。
  
- TCP报文的源端口随机生成，目的端口根据你的请求，如果是HTTP请求那就是80 如果是其他就是其他规定的端口

- TCP可靠传输 可以看看他的报文头部

- 搞清楚 包发给谁 查一下路由表，根据路由表获得的ip然后使用arp协议找到对应路由器的mac地址，操作系统也会有arp缓存 不是每次都要广播获取

- 在网络包传输的过程中，**源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址**，因为需要 MAC 地址在以太网内进行**两个设备**之间的包传输。

- **HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。**

- GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。

  POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。
  （但不完全是这样  可以用get实现新增和删除那就不是安全和幂等了，用post实现查询，那就是安全和幂等）

- GET请求其实也是可以带上body的同时POST请求的URL中也可以有参数

- HTTP（1.1）优缺点一体的**双刃剑**，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。

- HTTP（1.1）性能 1、长连接 2、管道网络传输 3、响应队头阻塞

- SSL/TLS 协议基本流程：

  - 客户端向服务器索要并验证服务器的公钥。
  - 双方协商生产「会话秘钥」。
  - 双方采用「会话秘钥」进行加密通信。

- HTTP/1.1 相比 HTTP/1.0 性能上的改进：

  - 使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
  - 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

- HTTP/1.1 还是有性能瓶颈：

  - 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 `Body` 的部分；
  - 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
  - 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；
  - 没有请求优先级控制；
  - 请求只能从客户端开始，服务器只能被动响应。

- HTTP/2 相比 HTTP/1.1 性能上的改进：1、头部压缩 2、二进制格式 （原来传200 用三个字符转成二进制 24位 现在200直接一个8位的就解决掉了）3、数据流 4、多路复用 5、服务器推送

- HTTP/2缺陷 还是存在队头阻塞问题 **HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。**
  ![Snipaste_2022-05-13_09-36-46.png](https://s2.loli.net/2022/05/13/TVburJkjdUBQXes.png)

- HTTP/3 优化：使用了QUIC+UDP  QUIC可以实现类似TCP的可靠传输  有以下特点1、无队头阻塞 2、更快的连接建立 3、连接迁移

- 





























